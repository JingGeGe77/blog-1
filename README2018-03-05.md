## 《JavaScript 语言精粹》(修订版) 读书笔记 ##
### 第四章 函数 Functions （二）  ###

### 参数 arguments  ###
   **arguments数组**： 函数可以通过此参数访问所有它被调用时传递给它的参数列表，包括哪些没有被分配给函数声明时定义的形式参数的多余参数。

  类似数组"(array-like)"的对象。arguments拥有一个length属性，没有任何数组方法。

***

### 返回 return   ###
  **return被执行，函数立刻返回而不再执行余下的语句**
  - 一个函数总是会返回一个值，没有指定返回值，则返回 undefined
  - 使用 new 调用函数，且返回值不是一个对象，则返回this (该新对象)

***

### 异常 Exceptions ###
  **异常是干扰程序的正常流程的不寻常（但并非完全是出乎意料的）事故**
  ```
   try {
     if(false) {
       throw {
         name:"TypeError",
         message:"number is required"
       }
     }
   }catch(e) {
     document.write(e.name + ": "+e.message)
   }

  ```
  throw 语句中断函数的运行。对象被传递到catch 从句中被捕获。

***
  ### 扩充类型的功能  ###
   **通过给Function.prototype 增加方法，来使得该方法对所有函数可用：**
  ```
     Function.prototype.method = function(name,func) {
       this.prototype[name] = func;
       return this;
     }
  ```
  这样在函数，数组，字符串，数字，正则表达式和布尔值等基本类型的构造函数上添加方法时，就可以省去prototype 这几个字符。使得对应的所有变量都适用改方法

  **为Number类型加上一个取整方法**
  ```
     Number.method('integer',function(){
         return Math[this<0?'ceil':'floor'](this);
       });
  ```
 **为String加上一个去除首尾空白的方法**
 ```
   String.method("trim",function(){
       return this.replace(/^\s+|\s+$/g,'');
    })
 ```

 **与类库一起混用是，在确定没有该方法时才添加它**
 ```
  // 符合条件时才增加方法
  Function.prototype.method = function(name,func) {
    if(!this.prototype[name]) {
      this.prototype[name] = func;
    }
    return this;
  }
 ```
***
### 递归 ###
  > 直接或者间接地调用自身的一种函数


***
### 作用域 ###
> 作用域控制着变量与参数的可见性及生命周期

** 函数作用域：** 定义在函数中的参数和变量在函数外部是不可见的，而在一个函数内部任何位置定义的变量，在该函数内部任何地方都可见。

在JavaScript中缺少会计作用域，最好的做法是在函数体的顶部声明函数中可能用到的所有变量。

***
### 闭包 Closure ###
> 闭包：函数可以访问它被创建时所处的上下文环境。

> 内部函数可以访问外部函数的实际变量而无需复制

作用域的好处是内部函数可以访问定义它们的外部函数的参数和变量（除了this 和arguments）

  内部函数拥有比它的外部函数更长的生命周期。

  ```
    var myObject = (function(){
      var value = 0;
      return {
        increment:function(inc) {
          value += typeof inc === 'number' ?inc :1;
        },
        getValue:function() {
          return value;       
        }
      }

    })()
  ```
 上面定义的value变量对increment和getValue方法总是可用的，但函数的作用域使得它对其他的程序来说是不可见的

***
 ### 回调 Callbacks ###
>  异步请求，提供一个服务器的响应到达是随即触发的回调函数，
  异步函数立即返回。

***
### 模块 Module ###
 > 使用 函数 和 闭包创造模块

模板的一般形式：
  - 一个定义了私有变量和函数的函数
  - 利用闭包创建可以访问私有变量和函数的特权函数
  - 返回这个特权函数，或者把它们保存到一个可访问到的地方。

利用前面使用的`method`方法，为String 增加一个deentityify 方法，寻找字符串中的HTML字符实体并把它们替换为对应的字符。
```
  String.method('deentityify',function(){
     // 字符实体表，它映射字符实体的名字到对应的字符
     var entity = {
       quot: '"',
       lt:'<',
       gt:'>'
     };
    // 返回 deetityify 方法
    return function() {
      // 下面就是deetityify方法，
      return this.replace(/&([^&;]+);/g,
          function(a,b){
            var r = entity[b];
            return typeof r === 'string'?r:a;
          }
      )
    }   
  }());
```
最后，使用()运算符立刻调用我们刚刚构造出来的函数，这个调用所创建并返回的函数才是`deentityify`方法
```
  document.writeln('&lt;&quot;&gt;'.deentityify())    // <">
```
